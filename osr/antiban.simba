type
  TAntibanTask = record
    BaseInterval: Double;
    NextAtTime: Double;
    Method: procedure of object;
  end;

  TAntiban = record
    ActiveSkill: Int32;
    Tasks: array of TAntibanTask;
    TasksDone: TStringArray;
  end; 

{$IFDEF RSCLIENT}
  {$DEFINE LOSE_FOCUS := RSClient.LoseFocus();}
  {$DEFINE GAIN_FOCUS := RSClient.SetFocus();}
{$ELSE}
  {$DEFINE LOSE_FOCUS := srl.MouseOffClient();}
  {$DEFINE GAIN_FOCUS := (*nothing*);}
{$ENDIF} 
  
procedure TSRL.HoverRandomPlayer(OptionChance:Double=30; waitMean:Double=3500);
var
  arr: TOptionArray;
  TPA: TPointarray;
  wt: Double;
  oldPos, pt: TPoint;
begin
  oldPos := mouse.GetPosition();

  for 0 to Trunc(srl.TruncatedGauss(0,3.5)) do
  begin
    TPA := Minimap.GetDots(MMDotPlayer);
    FilterPointsDist(TPA,0,24, MM2MS.MMCX, MM2MS.MMCY);
    if Length(TPA) = 0 then Exit;

    pt := TPA[Random(0,High(TPA))];
    pt := Minimap.VecToMs(Vec3(pt.x,pt.y,2));

    if not MainScreen.GetBounds.Contains(pt) then
      Continue;

    Mouse.Move(pt,8);
    WaitEx(70,10);
    if (Random()*100 <= OptionChance) and (MainScreen.IsUpText('level')) then
    begin
      ChooseOption.Open();
      if (Random(2) = 0) then
      begin
        arr := ChooseOption.GetOptions();
        if (arr <> []) then
        begin
          WaitEx(220,30);
          Mouse.Move(arr[Random(0,High(arr))].Bounds);
        end;
      end;
      WaitEx(waitMean,waitMean*0.08);
      ChooseOption.Close();
    end else
    begin
      wt := GetTickCount + srl.GaussRand(waitMean,waitMean*0.08);
      while (GetTickCount < wt) and (MainScreen.IsUpText('level')) do Wait(50);
      WaitEx(70,10);
    end;
  end;

  if Random(4) <> 0 then
    Mouse.Move(oldPos.Random(0,80,False));
end;

procedure TSRL.MouseOffClient(direction: Byte);
var
  W,H: Int32;
  pt: TPoint;
begin
  GetClientDimensions(W, H);
  pt := Mouse.GetPosition();
  if (pt.X < 0) or (pt.X > W) or (pt.Y < 0) or (pt.Y > H) then
    Exit();
  if (direction >= 4) then
    direction := Random(0,3);
  case direction of
    0: Mouse.Move(Box(-300, -300, W, 0)); // top
    1: Mouse.Move(Box(0, H, W, H+300));   // bottom
    2: Mouse.Move(Box(-300, 0, 0, H));    // left
    3: Mouse.Move(Box(W, 0, W+300, H));   // right
  end;
end;


procedure TSRL.MouseOffClient(); overload;
begin
  MouseOffClient(Trunc(srl.TruncatedGauss(0,4.1)));
end;

// experimental
function TSRL.DismissRandom(): Boolean;
var
  i: Int32;
  textAt: TPoint;
  TPA, Dots: TPointarray;
  msText: TMSTextArray := MainScreen.GetText(clYellow);
  name: String := Chatbox.GetDisplayName();
begin
  for i:=0 to High(msText) do
    if(name in msText[i].Text) then
    begin
      textAt := msText[i].Bounds.Middle + Point(0,10);
      break;
    end;

  if (textAt = Point(0,0)) then
    Exit;

  Dots := Minimap.GetDots(MMDotNPC);
  for i:=0 to High(Dots) do
    TPA += Minimap.VecToMs(Vec3(Dots[i].x, Dots[i].y, 2));

  TPA.Sort(textAt);
  for i:=0 to High(TPA) do
  begin
    if Distance(TPA[i], Mainscreen.GetMiddle()) > 80 then
      Break;

    Mouse.Move(TPA[i],5);
    WaitEx(60,30);
    if not MainScreen.IsUpText('Talk-to') then
      Continue;

    if ChooseOption.Select('Dismiss') then
    begin
      WaitEx(670,40);
      while minimap.isPlayerMoving() do Wait(40);
      Exit(True);
    end;
  end;
end;

// ------------------------------------------------------------------------
// TAntiban
procedure TAntiban.DebugNote(s: String);
begin
  Self.TasksDone += '['+FormatDateTime('hh:mm:ss', Now())+']' + s;
  if soDebugAntiban in srl.Options then
    WriteLn(Self.TasksDone[High(Self.TasksDone)]);
  if Length(Self.TasksDone) > 50 then
    Self.TasksDone.Del(0);
end;

procedure TAntiban.LoseFocus();
begin
  DebugNote('[RND] Losing focus');
  {$MACRO LOSE_FOCUS}
  WaitEx(19211,2000);
  {$MACRO GAIN_FOCUS}
  Players.GetCurrent()^.Login();
  if Random(4)=0 then Stats.HoverSkill(Self.ActiveSkill, srl.GaussRand(3000,400));
end;

procedure TAntiban.HoverPlayers();
begin
  DebugNote('[RND] Hovering players');
  srl.HoverRandomPlayer(25);
end;

procedure TAntiban.CheckSkill();
begin
  DebugNote('[RND] Check Skill Stats');
  Stats.HoverSkill(Self.ActiveSkill, srl.GaussRand(2500,300), Random(5) > 1);
end;

procedure TAntiban.RandomCompass();
begin
  DebugNote('[RND] Rotate Compass');
  Minimap.RandomCompass(-180,180, Random(5)=0);
end;

procedure TAntiban.CheckStats();
begin
  DebugNote('[RND] Look at Stats');
  Stats.Open();
  WaitEx(3000,300);
  if Random(2) = 0 then Inventory.Open();
end;

procedure TAntiban.OpenRandomTab();
begin
  DebugNote('[RND] Open Random Tab');
  Gametabs.Open(EGametab(Random(High(Gametabs.Tabs))));
  WaitEx(1600,100);
  if Random(4) = 0 then Inventory.Open()
  else if Random(4) = 0 then Stats.Open();
end;

procedure TAntiban.VeryShortBreak();
begin
  DebugNote('[RND] Taking a breather');
  if(Random(2)=0) then {$MACRO LOSE_FOCUS}
  WaitEx(40000,5000);
  {$MACRO GAIN_FOCUS}
  Players.GetCurrent()^.Login();
  Wait(60,600, wdLeft);
  Stats.HoverSkill(Self.ActiveSkill, srl.GaussRand(3000,400));
end;

procedure TAntiban.DoMiscStuff();
begin
  DebugNote('[RND] Doing misc stuff');
  for 0 to Random(2) do
  begin
    if Random(3) = 0 then
      Gametabs.Open(EGametab(Random(High(Gametabs.Tabs))));

    WaitEx(1500,200);
    if(Random(8) = 0) then
    begin
      if(Random(2) = 0) then {$MACRO LOSE_FOCUS}
      WaitEx(40000,4500);
      {$MACRO GAIN_FOCUS}
    end;

    if(Random(4) > 1) then
    begin
      Stats.HoverSkill(Self.ActiveSkill, srl.GaussRand(3000,400), Random(5) > 1);
      WaitEx(2500,300);
    end;
  end;
end;

procedure TAntiban.TakeBreak();
begin
  DebugNote('[RND] Taking a longer break');
  if(Random(2)=0) then Logout.ClickLogout();
  if(Random(2)=0) then {$MACRO LOSE_FOCUS}
  WaitEx(ONE_MINUTE*35,ONE_MINUTE*7);
  {$MACRO GAIN_FOCUS}
  Players.GetCurrent()^.Login();
  Wait(60,600, wdLeft);
  if Random(2) then Stats.HoverSkill(Self.ActiveSkill, srl.GaussRand(3000,400));
end;


function TAntiban.Init(Skill: Int32; Tasks: array of TAntibanTask=[]; IntervalRnd:Double=0.1): Boolean;
var i: Int32;
begin
  Self.ActiveSkill := Skill;
  Self.Tasks := Tasks;

  for i:=0 to High(Self.Tasks) do
    with Self.Tasks[i] do
    begin
      BaseInterval := srl.GaussRand(BaseInterval, BaseInterval*IntervalRnd);
      NextAtTime   := GetTimeRunning() + Random() * BaseInterval;
    end;
end;

function TAntiban.AddTask(Task: TAntibanTask; IntervalRnd:Double=0.1): Boolean;
begin
  Task.BaseInterval := srl.GaussRand(Task.BaseInterval, Task.BaseInterval*IntervalRnd);
  Task.NextAtTime   := GetTimeRunning() + Random() * Task.BaseInterval;
  Self.Tasks += Task;
end;

function TAntiban.DoAntiban(): Boolean;
var
  i,j,PauseLen: Int32;
begin
  for i:=0 to High(Self.Tasks) do
    if GetTimeRunning() > Self.Tasks[i].NextAtTime then
    begin
      Self.Tasks[i].Method();
      Self.Tasks[i].NextAtTime := GetTimeRunning() + srl.GaussRand(Self.Tasks[i].BaseInterval, Self.Tasks[i].BaseInterval*0.125);
      Result := True;
    end;
end;  
