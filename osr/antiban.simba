procedure TSRL.HoverRandomPlayer(waitMean:Double=3500);
var
  arr: TOptionArray;
  TPA: TPointarray;
  wt: Double;
  oldPos, pt: TPoint;
begin
  oldPos := mouse.GetPosition();

  for 0 to Trunc(srl.TruncatedGauss(0,3.1)) do
  begin
    TPA := Minimap.GetDots(MMDotPlayer);
    FilterPointsDist(TPA,0,30, MM2MS.MMCX, MM2MS.MMCY);
    if Length(TPA) = 0 then Exit;

    pt := TPA[Random(0,High(TPA))];
    pt := Minimap.VecToMs(Vec3(pt.x,pt.y,2));
    Mouse.Move(pt,10);

    WaitEx(70,10);
    if (Random(3) <> 0) and (MainScreen.IsUpText('level')) then
    begin
      ChooseOption.Open();
      if (Random(2) = 0) then
      begin
        arr := ChooseOption.GetOptions();
        if (arr <> []) then
        begin
          WaitEx(220,30);
          Mouse.Move(arr[Random(0,High(arr))].Bounds);
        end;
      end;
      WaitEx(waitMean,waitMean*0.08);
      ChooseOption.Close();
    end else
    begin
      wt := GetTickCount + srl.GaussRand(waitMean,waitMean*0.08);
      while (GetTickCount < wt) and (MainScreen.IsUpText('level')) do Wait(50);
      WaitEx(600,80);
    end;
  end;

  if Random(4) <> 0 then
    Mouse.Move(oldPos.Random(0,80,False));
end;

procedure TSRL.MouseOffClient(direction: Byte);
var
  W,H: Int32;
  pt: TPoint;
begin
  GetClientDimensions(W, H);
  pt := Mouse.GetPosition();
  if (pt.X < 0) or (pt.X > W) or (pt.Y < 0) or (pt.Y > H) then
    Exit();
  if (direction >= 4) then
    direction := Random(0,3);
  case direction of
    0: Mouse.Move(Box(-300, -300, W, 0)); // top
    1: Mouse.Move(Box(0, H, W, H+300));   // bottom
    2: Mouse.Move(Box(-300, 0, 0, H));    // left
    3: Mouse.Move(Box(W, 0, W+300, H));   // right
  end;
end;


procedure TSRL.MouseOffClient(); overload;
begin
  MouseOffClient(Trunc(srl.TruncatedGauss(0,4.1)));
end;
