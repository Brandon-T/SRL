// Experimental antiban, and breaksystem.
// Could contain some issues, and for that reason breaking changes may happen.
type
  TAntibanTask = record
    Method: procedure of object;
    Interval: Double;
    StdVar: Double;
    NextAtTime: Double;
  end;

  TBreakTask = record
    Interval: Double;
    Length: Double;
    LogoutChance: Double;
    StdVar: Double;
    NextAtTime, PrevAtTime: Double;
  end;

  TAntiban = record
    ActiveSkills: TIntArray;
    Tasks: array of TAntibanTask;
    Breaks: array of TBreakTask;

    HistorySize: Int32;
    TasksDone: TStringArray;
  end;

{$ifndef codeinsight}
procedure TSRL.LoseFocus();
begin
  srl.MouseOffClient();
  //this is just a stub - use rsclient for this funcionallity
end;

procedure TSRL.SetFocus();
begin
  //this is just a stub - use rsclient for this funcionallity
end;
{$endif}

procedure TSRL.HoverRandomPlayer(OptionChance:Double=30; waitMean:Double=3500);
var
  arr: TOptionArray;
  TPA: TPointarray;
  wt: Double;
  oldPos, pt: TPoint;
begin
  oldPos := mouse.GetPosition();

  for 0 to Trunc(srl.TruncatedGauss(0,3.5)) do
  begin
    TPA := Minimap.GetDots(MMDotPlayer);
    FilterPointsDist(TPA,0,24, MM2MS.MMCX, MM2MS.MMCY);
    if Length(TPA) = 0 then Exit;

    pt := TPA[Random(0,High(TPA))];
    pt := srl.RandomPoint(Minimap.VecToMsRect(Vec3(pt.x,pt.y,2)));
    
    if not MainScreen.GetBounds.Contains(pt) then
      Continue;

    Mouse.Move(pt);
    WaitEx(70,10);
    if (Random()*100 <= OptionChance) and (MainScreen.IsUpText('level')) then
    begin
      ChooseOption.Open();
      if (Random(2) = 0) then
      begin
        arr := ChooseOption.GetOptions();
        if (arr <> []) then
        begin
          WaitEx(220,30);
          Mouse.Move(arr[Random(0,High(arr))].Bounds);
        end;
      end;
      WaitEx(waitMean,waitMean*0.08);
      ChooseOption.Close();
    end else
    begin
      wt := GetTickCount + srl.GaussRand(waitMean,waitMean*0.08);
      while (GetTickCount < wt) and (MainScreen.IsUpText('level')) do Wait(50);
      WaitEx(70,10);
    end;
  end;

  if Random(4) <> 0 then
    Mouse.Move(oldPos.Random(0,80,False));
end;

procedure TSRL.MouseOffClient(direction: Byte);
var
  W,H: Int32;
  pt: TPoint;
begin
  GetClientDimensions(W, H);
  pt := Mouse.GetPosition();
  if (pt.X < 0) or (pt.X > W) or (pt.Y < 0) or (pt.Y > H) then
    Exit();
  if (direction >= 4) then
    direction := Random(0,3);
  case direction of
    0: Mouse.Move(Box(-300, -300, W, 0)); // top
    1: Mouse.Move(Box(0, H, W, H+300));   // bottom
    2: Mouse.Move(Box(-300, 0, 0, H));    // left
    3: Mouse.Move(Box(W, 0, W+300, H));   // right
  end;
end;


procedure TSRL.MouseOffClient(); overload;
begin
  MouseOffClient(Trunc(srl.TruncatedGauss(0,4.1)));
end;

// experimental
function TSRL.DismissRandom(): Boolean;
var
  i: Int32;
  textAt: TPoint;
  TPA, Dots: TPointarray;
  msText: TMSTextArray := MainScreen.GetText(clYellow);
  name: String := Chatbox.GetDisplayName();
begin
  for i:=0 to High(msText) do
    if(name in msText[i].Text) then
    begin
      textAt := msText[i].Bounds.Middle + Point(0,10);
      break;
    end;

  if (textAt = Point(0,0)) then
    Exit;

  Dots := Minimap.GetDots(MMDotNPC);
  for i:=0 to High(Dots) do
    TPA += Minimap.VecToMs(Vec3(Dots[i].x, Dots[i].y, 2));

  TPA.Sort(textAt);
  for i:=0 to High(TPA) do
  begin
    if Distance(TPA[i], Mainscreen.GetMiddle()) > 80 then
      Break;

    Mouse.Move(TPA[i],5);
    WaitEx(60,30);
    if not MainScreen.IsUpText('Talk-to') then
      Continue;

    if ChooseOption.Select('Dismiss') then
    begin
      WaitEx(670,40);
      while minimap.isPlayerMoving() do Wait(40);
      Exit(True);
    end;
  end;
end;


// ------------------------------------------------------------------------
// utilities

procedure TAntiban.DebugNote(s: String; AddToList:Boolean=True);
var
  text: String;
begin
  text := '['+FormatDateTime('hh:mm:ss', Now())+']' + s;
  if soDebugAntiban in srl.Options then
    WriteLn(text);

  if AddToList then
  begin
    Self.TasksDone += text;
    if Length(Self.TasksDone) > Self.HistorySize then
      Self.TasksDone.Del(0);
  end;
end;


// ------------------------------------------------------------------------
// tasks

procedure TAntiban.LoseFocus();
begin
  DebugNote('[RND] Losing focus');
  SRL.LoseFocus();
  WaitEx(15000, 2000);
  SRL.SetFocus();
  Players.GetCurrent()^.Login();
end;

procedure TAntiban.HoverPlayers();
begin
  DebugNote('[RND] Hovering players');
  srl.HoverRandomPlayer(25);
end;

procedure TAntiban.CheckSkill();
var
  Skill:Int32;
begin
  DebugNote('[RND] Check Skill Stats');
  if Length(ActiveSkills) > 0 then
  begin
    Skill := Self.ActiveSkills[Random(Length(Self.ActiveSkills))];
    Stats.HoverSkill(Skill, srl.GaussRand(2500,300), Random(3)=0);
  end;
end;

procedure TAntiban.RandomCompass();
begin
  DebugNote('[RND] Rotate Compass');
  Minimap.RandomCompass(-180,180, Random(5)=0);
end;

procedure TAntiban.RandomCompassNESW();
begin
  DebugNote('[RND] Rotate Compass [N,E,S,W]');
  Minimap.SetCompassAngle([0,270,180,90][Random(4)]+Random(-10,10), Random(5)=0);
end;

procedure TAntiban.CheckStats();
begin
  DebugNote('[RND] Look at Stats');
  Stats.Open();
  if Random(4)=0 then
    Stats.HoverSkill(Random(SKILL_TOTAL), srl.GaussRand(3000,300))
  else
    WaitEx(3000,300);
  if Random(2) = 0 then
    Inventory.Open();
end;

procedure TAntiban.OpenRandomTab();
begin
  DebugNote('[RND] Open Random Tab');
  Gametabs.Open(EGametab(Random(High(Gametabs.Tabs))));
  WaitEx(1600,100);
  if Random(4) = 0 then Inventory.Open()
  else if Random(4) = 0 then Stats.Open();
end;

procedure TAntiban.VeryShortBreak();
begin
  DebugNote('[RND] Taking a breather');
  if(Random(2)=0) then SRL.LoseFocus();
  WaitEx(30000,5000);
  SRL.SetFocus();
  Players.GetCurrent()^.Login();
  Wait(60,600, wdLeft);
  if Random(4) = 0 then Self.CheckSkill();
end;

procedure TAntiban.FiveMinBreak();
begin
  DebugNote('[RND] Taking 5 minutes');
  if(Random(2) = 0) then Logout.ClickLogout();
  if(Random(2) = 0) then SRL.LoseFocus();
  WaitEx(ONE_MINUTE*5, ONE_MINUTE);
  SRL.SetFocus();
  Players.GetCurrent()^.Login();
  Wait(60,600, wdLeft);
  if Random(4) = 0 then Self.CheckSkill();
end;

procedure TAntiban.DoMiscStuff();
begin
  DebugNote('[RND] Doing misc stuff');
  for 0 to Random(2) do
  begin
    if Random(3) = 0 then
      Gametabs.Open(EGametab(Random(High(Gametabs.Tabs))));

    WaitEx(1500,200);
    if(Random(8) = 0) then
    begin
      if(Random(2) = 0) then SRL.LoseFocus();
      WaitEx(40000,4500);
      SRL.SetFocus();
    end;

    if(Random(3) = 0) then
    begin
      Self.CheckStats();
      WaitEx(2000,200);
    end;
  end;
end;

procedure TAntiban.TakeBreak(Task: TBreakTask);
var
  len: Int64;
begin
  len := Round(srl.GaussRand(Task.Length, Task.Length * Task.StdVar));

  Self.DebugNote('[BREAK] Pausing for '+ srl.MsToTime(len, Time_Formal_Long));
  if(Random() > Task.LogoutChance) then Logout.ClickLogout();
  if(Random() > Task.LogoutChance) then SRL.LoseFocus();

  while(len > 0) do
  begin
    Wait(Trunc(Min(ONE_MINUTE*5, len)));
    len -= Min(ONE_MINUTE*5, len);
    Self.DebugNote('[BREAK] '+ srl.MsToTime(len, Time_Formal_Long)+' left', False);
  end;

  SRL.SetFocus();
  Players.GetCurrent()^.Login();
  Wait(60,600, wdLeft);
  if Random(2)=0 then Self.CheckSkill();
end;


// ----------------------------------------------------------------------------
// TAntiban setup and such

function TAntiban.Init(Skills: TIntArray; LogSize:Int32=5): Boolean;
var i: Int32;
begin
  Self.ActiveSkills := Skills;
  Self.HistorySize := LogSize;
end;

function TAntiban.Init(Skill: Int32; LogSize:Int32=5): Boolean; overload; //simple 1 skill
var i: Int32;
begin
  Self.ActiveSkills := [Skill];
  Self.HistorySize := LogSize;
end;

function TAntiban.AddTask(Task: TAntibanTask): Boolean;
begin
  with Task do
  begin
    if StdVar = 0 then StdVar := 0.25;
    NextAtTime := GetTimeRunning() + srl.GaussRand(Interval, Interval * StdVar);
  end;
  Self.Tasks += Task;
end;

function TAntiban.AddBreak(Task: TBreakTask): Boolean;
begin
  with Task do
  begin
    if StdVar = 0 then StdVar := 0.1;
    NextAtTime := GetTimeRunning() + srl.GaussRand(Interval, Interval * StdVar);
  end;
  Self.Breaks += Task;
end;

// resets all antibans, but to a completely randomized start time.
function TAntiban.RestartAntiban(): Boolean;
var i: Int32;
begin
  for i:=0 to High(Self.Tasks) do
    with Self.Tasks[i] do
      NextAtTime := GetTimeRunning() + Random() * Interval;
end;

// checks for antibans, and breaks, and runs it if it should
function TAntiban.DoAntiban(CheckBreaks: Boolean = True): Boolean;
var
  i, PauseStart: Int32;
  procedure OffsetBreaks(UpTo, Length: Int32);
  var i:Int32;
  begin
    for i:=0 to UpTo do
      Self.Breaks[i].NextAtTime += Length;
  end;
begin
  // check for antiban
  for i:=0 to High(Self.Tasks) do
    if GetTimeRunning() > Self.Tasks[i].NextAtTime then
      with Self.Tasks[i] do
      begin
        Method();
        NextAtTime := GetTimeRunning() + srl.GaussRand(Interval, Interval * StdVar);
        Result := True;
        i := -1;
      end;

  // check for breaks
  if CheckBreaks then
    for i:=0 to High(Self.Breaks) do
      if GetTimeRunning() > Self.Breaks[i].NextAtTime then
        with Self.Breaks[i] do
        begin
          NextAtTime := GetTimeRunning() + srl.GaussRand(Interval, Interval * StdVar);

          PauseStart := GetTimeRunning();
          Self.TakeBreak(Self.Breaks[i]);
          OffsetBreaks(i, GetTimeRunning() - PauseStart );

          PrevAtTime := GetTimeRunning();
          Self.RestartAntiban();
          Exit(True);
        end;
end;


// how long since last break, in ms
function TAntiban.TimeSinceBreak(LongerThan:Double=0): UInt64;
var i: Int32;
begin
  for i:=0 to High(Self.Breaks) do
    if (Self.Breaks[i].Length >= LongerThan) and (Self.Breaks[i].PrevAtTime >= Result) then
      Result := Trunc(Self.Breaks[i].PrevAtTime);
  Result := GetTimeRunning() - Result;
end;


// The idea here is that we gather the time the past ?? that has
// gone into being pauses.
function TAntiban.BreaksPast(Timespan: Double): Int64;
var
  XHoursAgo: Double := GetTimeRunning() - Timespan;
  active, started: Double;
  i: Int32;
begin
  Active := Min(Timespan, GetTimeRunning());
  for i:=0 to High(Self.Breaks) do
    if Self.Breaks[i].PrevAtTime >= XHoursAgo then
    begin
      if Self.Breaks[i].PrevAtTime = 0 then
        Continue;
      started := Max(XHoursAgo, Self.Breaks[i].PrevAtTime - Self.Breaks[i].Length);
      Active -= Self.Breaks[i].PrevAtTime - started;
    end;

  Result := Round(Min(Timespan, Timespan - Active));
end;

// Combines ratio of pause to active past 2 hours, and time since last break
// to produce a energy level that ranges from 0 to 100.
function TAntiban.EnergyLevel(): Double;
var
  zz: Int32;
  t,eLeftFromSleep, eLeftFromBreak, eBreakValue: Double;
begin
  eLeftFromBreak := Max(0,Min(1,1-Power((Self.TimeSinceBreak() / (18*ONE_HOUR)), 1/3)));
  eBreakValue    := Power(Self.BreaksPast(2*ONE_HOUR) / (2*ONE_HOUR), 1/3);
  Result         := Max(0,Min(1,(eLeftFromBreak + eBreakValue) / 1.8));

  zz := High(Self.Breaks);
  if (Self.Breaks[zz].Length) > 5*ONE_HOUR then // if we have a sleep
  begin
    t := GetTimeRunning() - Trunc(Self.Breaks[zz].PrevAtTime);
    eLeftFromSleep := Max(0,Min(1,t / (20*ONE_HOUR)));
    eLeftFromSleep := Power(1-eLeftFromSleep, 1/4);
    Result := eLeftFromSleep * Result;
  end;
  Result := 100 * Result;
end;

// Energy based wait, if energy is 100% then wait length is 0.
// It scales exponentially, by default (Exp = 0.2):
//   1%  of the length at 97% energy
//   11% of the length at 75% energy
//   25% of the length at 50% energy
//   48% of the length at 25% energy
//   73% of the length at 10% energy
//   90% of the length at 5%  energy
procedure TAntiban.WaitFatigue(t: Double; Exp: Double=0.2);
begin
  System.Wait(Trunc(2*t * (1-Power(System.Max(0.0001, Self.EnergyLevel()/100),Exp))));
end;



