// prototype
{$IFNDECL(Vector3)} {$I structures.simba} {$ENDIF}

function MM2MS_Core(PT: Vector3; Roll:Single=$FFFF; PointRot:Boolean=True): TPoint;
const
  W = 513; //mainscreen W and H
  H = 335;

  function Transform(coord: Vector3; matrix: TMatrix4): Vector3;
  var p: Vector3;
  begin
    p := Vector3.TransformCoordinate(coord, matrix);
    Result.x := (+p.X * W) + (W / 2);
    Result.y := (-p.Y * H) + (H / 2);
  end;

  function Project(coords: TVector3Array; Rotation: Vector3): TPointArray;
  var
    vec: Vector3;
    viewMatrix, projMatrix, worldMatrix,transMatrix: TMatrix4;
  begin
    viewMatrix := TMatrix4.LookAtRH([0,0,57], [0,0,0], Vector3_UnitY);
    projMatrix := TMatrix4.PerspectiveFovRH(1.41, 1.52, 0.01, 1.0);

    worldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
    transMatrix := worldMatrix * viewMatrix * projMatrix;
    for vec in coords do
    begin
      vec := Transform(vec, transMatrix);
      Result += Point(Round(vec.x),Round(vec.y));
    end;
  end;
var
  v: Vector3;
begin
  if (Roll = $FFFF) then
    Roll := minimap.GetCompassAngle(False);

  if PointRot then
    PT := PT.RotateXY(PI*2 - Roll, 642,85);

  v := [(PT.x - 642), (85 - PT.y), PT.z];
  Result := Project([v], Vec3(-0.40, 0, PI*2 - Roll))[0];
end;
