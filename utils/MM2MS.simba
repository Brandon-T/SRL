// prototype
{$IFNDECL(Vector3)} {$I structures.simba} {$ENDIF}

function MM2MS_Core(pt: Vector2; z:Single=0; Angle:Single=-1; PointRot:Boolean=True): TPoint;
const
  W = 513; //mainscreen W and H
  H = 335;

  function Transform(coord: Vector3; matrix: TMatrix4): Vector3;
  var p: Vector3;
  begin
    p := Vector3.TransformCoordinate(coord, matrix);
    Result.x := (+p.X * W) + (W / 2);
    Result.y := (-p.Y * H) + (H / 2);
  end;

  function Project(coords: TVector3Array; Rotation: Vector3): TPointArray;
  var
    vec: Vector3;
    viewMatrix, projMatrix, worldMatrix,transMatrix: TMatrix4;
  begin
    viewMatrix := TMatrix4.LookAtRH([0,0,57], [0,0,0], Vector3_UnitY);
    projMatrix := TMatrix4.PerspectiveFovRH(1.41, 1.52, 0.01, 1.0);

    worldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
    transMatrix := worldMatrix * viewMatrix * projMatrix;
    for vec in coords do
    begin
      vec := Transform(vec, transMatrix);
      Result += Point(Round(vec.x),Round(vec.y));
    end;
  end;
var
  v: Vector3;
begin
  if (angle = -1) then
    angle := minimap.GetCompassAngle(False);

  if PointRot then
    pt := pt.Rotate(PI*2 - angle, 642,85);

  v := [(pt.x - 642), (85 - pt.y), z];
  Result := Project([v], Vec3(-0.40, 0, PI*2 - angle))[0];
end;
